# 불변 컬렉션 코드 예시

## 기본 사용법

### ImmutableList<T> 예시

```csharp
using System;
using System.Collections.Immutable;
using System.Threading.Tasks;

class ImmutableListExample
{
    static void Main()
    {
        // 1. 빈 불변 리스트 생성
        var emptyList = ImmutableList<string>.Empty;
        
        // 2. 초기 데이터로 불변 리스트 생성
        var initialList = ImmutableList.Create("Apple", "Banana", "Cherry");
        
        // 3. 요소 추가 (새로운 인스턴스 반환)
        var newList = initialList.Add("Date");
        
        // 4. 여러 요소 추가
        var moreItems = newList.AddRange(new[] { "Elderberry", "Fig" });
        
        // 5. 요소 제거
        var removedItem = moreItems.Remove("Banana");
        
        // 6. 인덱스로 요소 제거
        var removedByIndex = removedItem.RemoveAt(0);
        
        Console.WriteLine($"Original: {string.Join(", ", initialList)}");
        Console.WriteLine($"Final: {string.Join(", ", removedByIndex)}");
        
        // 원본은 변경되지 않음을 확인
        Console.WriteLine($"Original unchanged: {string.Join(", ", initialList)}");
    }
}
```

### ImmutableDictionary<TKey, TValue> 예시

```csharp
using System;
using System.Collections.Immutable;

class ImmutableDictionaryExample
{
    static void Main()
    {
        // 1. 빈 딕셔너리 생성
        var emptyDict = ImmutableDictionary<string, int>.Empty;
        
        // 2. 초기 데이터로 딕셔너리 생성
        var scores = ImmutableDictionary.CreateBuilder<string, int>();
        scores.Add("Alice", 95);
        scores.Add("Bob", 87);
        scores.Add("Charlie", 92);
        var immutableScores = scores.ToImmutable();
        
        // 3. 새로운 항목 추가
        var updatedScores = immutableScores.Add("David", 89);
        
        // 4. 기존 항목 업데이트
        var finalScores = updatedScores.SetItem("Bob", 90);
        
        // 5. 항목 제거
        var withoutCharlie = finalScores.Remove("Charlie");
        
        // 6. 안전한 조회
        if (withoutCharlie.TryGetValue("Alice", out int aliceScore))
        {
            Console.WriteLine($"Alice's score: {aliceScore}");
        }
        
        // 7. 모든 항목 출력
        foreach (var kvp in withoutCharlie)
        {
            Console.WriteLine($"{kvp.Key}: {kvp.Value}");
        }
    }
}
```

## 멀티스레드 환경에서의 사용

### 스레드 안전한 읽기 작업

```csharp
using System;
using System.Collections.Immutable;
using System.Threading.Tasks;

class ThreadSafeReadingExample
{
    private static readonly ImmutableList<string> SharedData = 
        ImmutableList.Create("Item1", "Item2", "Item3", "Item4", "Item5");
    
    static async Task Main()
    {
        // 여러 작업이 동시에 같은 불변 컬렉션을 읽어도 안전
        var tasks = new Task[10];
        
        for (int i = 0; i < tasks.Length; i++)
        {
            int taskId = i;
            tasks[i] = Task.Run(() => ProcessData(taskId));
        }
        
        await Task.WhenAll(tasks);
    }
    
    static void ProcessData(int taskId)
    {
        // 동기화 없이 안전하게 접근 가능
        foreach (var item in SharedData)
        {
            Console.WriteLine($"Task {taskId}: Processing {item}");
            // 시뮬레이션 작업
            System.Threading.Thread.Sleep(100);
        }
        
        // 특정 인덱스 접근도 안전
        if (SharedData.Count > 2)
        {
            Console.WriteLine($"Task {taskId}: Third item is {SharedData[2]}");
        }
    }
}
```

### 상태 업데이트 패턴

```csharp
using System;
using System.Collections.Immutable;
using System.Threading;
using System.Threading.Tasks;

class StateUpdateExample
{
    private volatile ImmutableList<string> _items = ImmutableList<string>.Empty;
    private readonly object _updateLock = new object();
    
    public void AddItem(string item)
    {
        lock (_updateLock)
        {
            // 현재 상태를 읽고 새로운 상태를 생성
            _items = _items.Add(item);
        }
    }
    
    public void RemoveItem(string item)
    {
        lock (_updateLock)
        {
            _items = _items.Remove(item);
        }
    }
    
    public ImmutableList<string> GetSnapshot()
    {
        // 동기화 없이 현재 상태의 스냅샷 반환
        return _items;
    }
    
    static async Task Main()
    {
        var example = new StateUpdateExample();
        
        // 동시에 항목 추가
        var addTasks = new Task[5];
        for (int i = 0; i < addTasks.Length; i++)
        {
            int index = i;
            addTasks[i] = Task.Run(() => example.AddItem($"Item{index}"));
        }
        
        // 동시에 스냅샷 읽기
        var readTasks = new Task[3];
        for (int i = 0; i < readTasks.Length; i++)
        {
            readTasks[i] = Task.Run(() =>
            {
                var snapshot = example.GetSnapshot();
                Console.WriteLine($"Snapshot: {string.Join(", ", snapshot)}");
            });
        }
        
        await Task.WhenAll(addTasks.Concat(readTasks));
        
        Console.WriteLine($"Final state: {string.Join(", ", example.GetSnapshot())}");
    }
}
```

## 성능 최적화 패턴

### Builder 패턴 사용

```csharp
using System;
using System.Collections.Immutable;
using System.Linq;

class BuilderPatternExample
{
    static void Main()
    {
        // 비효율적인 방법: 매번 새로운 인스턴스 생성
        var inefficient = ImmutableList<int>.Empty;
        for (int i = 0; i < 1000; i++)
        {
            inefficient = inefficient.Add(i); // O(n) 복잡도가 누적됨
        }
        
        // 효율적인 방법: Builder 사용
        var builder = ImmutableList.CreateBuilder<int>();
        for (int i = 0; i < 1000; i++)
        {
            builder.Add(i); // O(1) 복잡도
        }
        var efficient = builder.ToImmutable();
        
        Console.WriteLine($"Both methods create lists of {inefficient.Count} items");
        Console.WriteLine($"Builder method is much faster for bulk operations");
    }
}
```

### 초기화 최적화

```csharp
using System;
using System.Collections.Immutable;
using System.Linq;

class InitializationExample
{
    static void Main()
    {
        // 방법 1: 직접 생성
        var method1 = ImmutableList.Create(1, 2, 3, 4, 5);
        
        // 방법 2: 기존 컬렉션에서 변환
        var source = Enumerable.Range(1, 5);
        var method2 = source.ToImmutableList();
        
        // 방법 3: Builder로 복잡한 초기화
        var builder = ImmutableList.CreateBuilder<(string Name, int Age)>();
        builder.Add(("Alice", 25));
        builder.Add(("Bob", 30));
        builder.Add(("Charlie", 35));
        var method3 = builder.ToImmutable();
        
        Console.WriteLine($"Method 1: {string.Join(", ", method1)}");
        Console.WriteLine($"Method 2: {string.Join(", ", method2)}");
        Console.WriteLine($"Method 3: {string.Join(", ", method3.Select(p => $"{p.Name}({p.Age})"))}");
    }
}
```

## 실제 사용 사례

### 설정 관리

```csharp
using System;
using System.Collections.Immutable;

class ConfigurationManager
{
    private volatile ImmutableDictionary<string, string> _config = 
        ImmutableDictionary<string, string>.Empty;
    
    public void LoadConfiguration(IDictionary<string, string> newConfig)
    {
        // 전체 설정을 원자적으로 교체
        _config = newConfig.ToImmutableDictionary();
    }
    
    public string GetSetting(string key, string defaultValue = "")
    {
        return _config.TryGetValue(key, out string value) ? value : defaultValue;
    }
    
    public ImmutableDictionary<string, string> GetAllSettings()
    {
        return _config; // 스냅샷 반환
    }
    
    public void UpdateSetting(string key, string value)
    {
        // CAS(Compare-And-Swap) 패턴으로 원자적 업데이트
        ImmutableDictionary<string, string> current, updated;
        do
        {
            current = _config;
            updated = current.SetItem(key, value);
        } while (Interlocked.CompareExchange(ref _config, updated, current) != current);
    }
}
```

### 이벤트 로그

```csharp
using System;
using System.Collections.Immutable;
using System.Threading.Tasks;

record LogEntry(DateTime Timestamp, string Level, string Message);

class EventLogger
{
    private volatile ImmutableList<LogEntry> _logs = ImmutableList<LogEntry>.Empty;
    private readonly object _lockObject = new object();
    
    public void Log(string level, string message)
    {
        var entry = new LogEntry(DateTime.UtcNow, level, message);
        
        lock (_lockObject)
        {
            _logs = _logs.Add(entry);
        }
    }
    
    public ImmutableList<LogEntry> GetLogs(DateTime? since = null)
    {
        var snapshot = _logs;
        
        if (since.HasValue)
        {
            return snapshot.Where(log => log.Timestamp >= since.Value).ToImmutableList();
        }
        
        return snapshot;
    }
    
    public void ClearOldLogs(TimeSpan maxAge)
    {
        var cutoff = DateTime.UtcNow - maxAge;
        
        lock (_lockObject)
        {
            _logs = _logs.Where(log => log.Timestamp >= cutoff).ToImmutableList();
        }
    }
}
```

이러한 예시들은 불변 컬렉션이 어떻게 스레드 안전성과 성능을 동시에 제공하는지 보여줍니다. 다음 장에서는 스레드 안전 컬렉션에 대해 알아보겠습니다.
# 스레드 안전 컬렉션 (Thread-Safe Collections)

## 스레드 안전 컬렉션의 특징

스레드 안전 컬렉션은 `System.Collections.Concurrent` 네임스페이스에서 제공되며, 여러 스레드가 동시에 안전하게 접근할 수 있도록 설계되었습니다.

### 핵심 특징
- **내부 동기화**: 컬렉션 내부에서 동기화를 처리하므로 외부 잠금이 불필요
- **Lock-free 알고리즘**: 대부분 잠금 없는 알고리즘을 사용하여 높은 성능 제공
- **원자적 연산**: 읽기-수정-쓰기 연산을 원자적으로 수행
- **높은 확장성**: 멀티코어 환경에서 우수한 성능
- **가변성**: 불변 컬렉션과 달리 직접 수정 가능

### 일반 컬렉션과의 차이점

| 특성 | 일반 컬렉션 | 스레드 안전 컬렉션 |
|------|-------------|-------------------|
| 스레드 안전성 | 없음 | 보장됨 |
| 동기화 필요성 | 외부에서 필요 | 내부에서 처리 |
| 성능 (단일 스레드) | 높음 | 약간 낮음 |
| 성능 (멀티 스레드) | 낮음 (경합 시) | 높음 |
| 메모리 오버헤드 | 낮음 | 약간 높음 |

## 주요 스레드 안전 컬렉션 타입

### ConcurrentDictionary<TKey, TValue>
가장 많이 사용되는 스레드 안전 컬렉션으로, 키-값 쌍을 저장합니다.

**특징:**
- Lock-free 읽기 연산
- 세밀한 잠금(fine-grained locking)을 사용한 쓰기 연산
- 원자적 업데이트 메서드 제공
- 높은 동시성 성능

**주요 메서드:**
- `TryAdd(TKey, TValue)`: 키가 없을 때만 추가
- `TryGetValue(TKey, out TValue)`: 안전한 값 조회
- `TryUpdate(TKey, TValue, TValue)`: 기존 값과 비교하여 업데이트
- `TryRemove(TKey, out TValue)`: 키 제거 및 값 반환
- `AddOrUpdate(TKey, TValue, Func<TKey, TValue, TValue>)`: 추가 또는 업데이트
- `GetOrAdd(TKey, Func<TKey, TValue>)`: 조회 또는 추가

### ConcurrentQueue<T>
FIFO(선입선출) 스레드 안전 큐입니다.

**특징:**
- Lock-free 구현
- 무한 크기 지원
- 높은 처리량

**주요 메서드:**
- `Enqueue(T)`: 요소 추가
- `TryDequeue(out T)`: 요소 제거 시도
- `TryPeek(out T)`: 첫 번째 요소 확인
- `IsEmpty`: 큐가 비어있는지 확인

### ConcurrentStack<T>
LIFO(후입선출) 스레드 안전 스택입니다.

**특징:**
- Lock-free 구현
- 무한 크기 지원
- 배치 연산 지원

**주요 메서드:**
- `Push(T)`: 요소 추가
- `TryPop(out T)`: 요소 제거 시도
- `TryPeek(out T)`: 최상위 요소 확인
- `PushRange(T[])`: 여러 요소 일괄 추가
- `TryPopRange(T[])`: 여러 요소 일괄 제거

### ConcurrentBag<T>
순서가 없는 스레드 안전 컬렉션입니다.

**특징:**
- 스레드 로컬 저장소 활용
- 동일한 스레드에서의 추가/제거 시 최적 성능
- 순서 보장 없음

**주요 메서드:**
- `Add(T)`: 요소 추가
- `TryTake(out T)`: 요소 제거 시도
- `TryPeek(out T)`: 요소 확인 시도
- `IsEmpty`: 컬렉션이 비어있는지 확인

### BlockingCollection<T>
생산자-소비자 시나리오를 위한 래퍼 컬렉션입니다.

**특징:**
- 다른 스레드 안전 컬렉션을 래핑
- 블로킹 연산 지원
- 경계 크기 설정 가능
- 완료 신호 지원

**주요 메서드:**
- `Add(T)`: 요소 추가 (블로킹 가능)
- `Take()`: 요소 제거 (블로킹)
- `TryAdd(T, int)`: 타임아웃을 가진 추가
- `TryTake(out T, int)`: 타임아웃을 가진 제거
- `CompleteAdding()`: 더 이상 추가하지 않음을 신호
- `GetConsumingEnumerable()`: 소비용 열거자 반환

## 성능 특성

### 시간 복잡도

| 컬렉션 | 추가 | 제거 | 조회 | 특징 |
|--------|------|------|------|------|
| `ConcurrentDictionary<TKey, TValue>` | O(1) 평균 | O(1) 평균 | O(1) 평균 | 해시 테이블 기반 |
| `ConcurrentQueue<T>` | O(1) | O(1) | N/A | FIFO 큐 |
| `ConcurrentStack<T>` | O(1) | O(1) | N/A | LIFO 스택 |
| `ConcurrentBag<T>` | O(1) | O(1) | N/A | 순서 없음 |
| `BlockingCollection<T>` | 내부 컬렉션에 의존 | 내부 컬렉션에 의존 | N/A | 래퍼 |

### 메모리 오버헤드
- **ConcurrentDictionary**: 일반 Dictionary보다 약 20-30% 더 많은 메모리 사용
- **ConcurrentQueue/Stack**: 일반 Queue/Stack과 유사
- **ConcurrentBag**: 스레드 로컬 저장소로 인한 추가 오버헤드
- **BlockingCollection**: 내부 컬렉션 + 동기화 객체

## 선택 가이드

### 언제 사용할까?

#### ConcurrentDictionary 사용 시나리오
- 캐시 구현
- 빈번한 읽기/쓰기가 있는 키-값 저장소
- 설정 또는 메타데이터 관리
- 스레드 안전한 룩업 테이블

#### ConcurrentQueue 사용 시나리오
- 작업 큐 구현
- 메시지 버퍼링
- 이벤트 순서 보장이 필요한 경우
- 생산자-소비자 패턴 (간단한 경우)

#### ConcurrentStack 사용 시나리오
- 임시 객체 풀
- 되돌리기(Undo) 기능
- 스레드 로컬 캐시 구현

#### ConcurrentBag 사용 시나리오
- 병렬 처리 결과 수집
- 임시 데이터 저장 (순서 무관)
- 스레드별 작업 결과 집계

#### BlockingCollection 사용 시나리오
- 생산자-소비자 패턴 (복잡한 경우)
- 백프레셔가 필요한 경우
- 완료 신호가 필요한 작업 큐

### 성능 고려사항

#### 읽기 vs 쓰기 비율
- **읽기 중심**: `ConcurrentDictionary`가 우수
- **쓰기 중심**: 컬렉션 타입에 따라 다름
- **혼합**: 사용 패턴에 따라 벤치마킹 필요

#### 경합 수준
- **낮은 경합**: 일반 컬렉션 + 잠금도 고려 가능
- **높은 경합**: 스레드 안전 컬렉션이 유리
- **매우 높은 경합**: Lock-free 구현이 중요

#### 메모리 압박
- **메모리 제약**: 오버헤드를 고려하여 선택
- **충분한 메모리**: 성능 우선으로 선택

다음 장에서는 이러한 스레드 안전 컬렉션들의 실제 사용 예시를 살펴보겠습니다.
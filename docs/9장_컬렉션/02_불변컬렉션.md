# 불변 컬렉션 (Immutable Collections)

## 불변 컬렉션의 특징

불변 컬렉션은 한 번 생성되면 내용을 변경할 수 없는 컬렉션입니다. 이러한 특성으로 인해 다음과 같은 장점을 제공합니다:

### 핵심 특징
- **스레드 안전성**: 불변이므로 여러 스레드에서 동시에 안전하게 접근 가능
- **구조적 공유**: 메모리 효율성을 위해 내부 구조를 공유
- **함수형 프로그래밍 지원**: 부작용 없는 프로그래밍 모델
- **예측 가능한 동작**: 상태 변경이 없어 디버깅과 테스트가 용이

### 구조적 공유 (Structural Sharing)
불변 컬렉션은 새로운 인스턴스를 만들 때 기존 데이터를 완전히 복사하지 않고, 변경되지 않은 부분은 공유합니다:

```
Original: [A, B, C, D]
Modified: [A, B, X, D]  // B와 D는 원본과 공유
```

## 주요 불변 컬렉션 타입

### ImmutableList<T>
- **용도**: 순서가 있는 요소들의 불변 목록
- **성능**: 인덱싱 O(log n), 추가/제거 O(log n)
- **특징**: 이진 트리 구조 사용

### ImmutableArray<T>
- **용도**: 고성능이 필요한 불변 배열
- **성능**: 인덱싱 O(1), 추가/제거 O(n)
- **특징**: 연속된 메모리 공간 사용

### ImmutableDictionary<TKey, TValue>
- **용도**: 키-값 쌍의 불변 딕셔너리
- **성능**: 조회/추가/제거 O(log n)
- **특징**: AVL 트리 기반 구현

### ImmutableHashSet<T>
- **용도**: 고유한 요소들의 불변 집합
- **성능**: 조회/추가/제거 O(log n)
- **특징**: 해시 트리 구조 사용

### ImmutableSortedDictionary<TKey, TValue>
- **용도**: 정렬된 키-값 쌍의 불변 딕셔너리
- **성능**: 조회/추가/제거 O(log n)
- **특징**: 키가 자동으로 정렬됨

### ImmutableSortedSet<T>
- **용도**: 정렬된 고유 요소들의 불변 집합
- **성능**: 조회/추가/제거 O(log n)
- **특징**: 요소가 자동으로 정렬됨

### ImmutableStack<T>
- **용도**: LIFO(후입선출) 불변 스택
- **성능**: Push/Pop O(1)
- **특징**: 링크드 리스트 기반

### ImmutableQueue<T>
- **용도**: FIFO(선입선출) 불변 큐
- **성능**: Enqueue/Dequeue O(1) 분할상환
- **특징**: 두 개의 스택으로 구현

## NuGet 패키지

불변 컬렉션을 사용하려면 다음 NuGet 패키지를 설치해야 합니다:

```xml
<PackageReference Include="System.Collections.Immutable" Version="7.0.0" />
```

### 패키지 설치 방법

#### .NET CLI
```bash
dotnet add package System.Collections.Immutable
```

#### Package Manager Console
```powershell
Install-Package System.Collections.Immutable
```

#### PackageReference (권장)
```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="System.Collections.Immutable" Version="7.0.0" />
  </ItemGroup>
</Project>
```

## 사용 시나리오

### 적합한 경우
- **읽기 중심 작업**: 데이터를 주로 읽기만 하는 경우
- **함수형 프로그래밍**: 부작용 없는 프로그래밍을 원하는 경우
- **스레드 안전성 필요**: 동기화 없이 여러 스레드에서 접근해야 하는 경우
- **데이터 무결성**: 데이터가 예기치 않게 변경되는 것을 방지하고 싶은 경우
- **스냅샷**: 특정 시점의 데이터 상태를 보존해야 하는 경우

### 부적합한 경우
- **빈번한 수정**: 데이터를 자주 변경해야 하는 경우
- **대량 데이터 처리**: 매우 큰 데이터셋을 다루는 경우
- **인덱스 기반 접근**: 인덱스로 빠른 접근이 필요한 경우 (`ImmutableArray` 제외)

## 성능 특성

| 컬렉션 타입 | 인덱싱 | 추가 | 제거 | 조회 | 메모리 효율성 |
|------------|--------|------|------|------|---------------|
| `ImmutableList<T>` | O(log n) | O(log n) | O(log n) | O(log n) | 높음 |
| `ImmutableArray<T>` | O(1) | O(n) | O(n) | O(n) | 매우 높음 |
| `ImmutableDictionary<TKey, TValue>` | N/A | O(log n) | O(log n) | O(log n) | 높음 |
| `ImmutableHashSet<T>` | N/A | O(log n) | O(log n) | O(log n) | 높음 |
| `ImmutableStack<T>` | N/A | O(1) | O(1) | O(n) | 높음 |
| `ImmutableQueue<T>` | N/A | O(1)* | O(1)* | O(n) | 높음 |

*분할상환 시간 복잡도

불변 컬렉션은 특별한 사용 사례에 매우 강력한 도구이지만, 모든 상황에 적합하지는 않습니다. 다음 장에서는 실제 코드 예시를 통해 불변 컬렉션의 효과적인 사용법을 알아보겠습니다.